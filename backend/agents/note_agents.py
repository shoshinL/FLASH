from typing import List
from langchain_core.output_parsers import PydanticOutputParser, JsonOutputParser
from langchain.output_parsers import OutputFixingParser
#from langchain_nvidia_ai_endpoints import ChatNVIDIA
from langchain_core.prompts import PromptTemplate
from pydantic import BaseModel, Field
import logging

from .note_models import (
    BasicModel, BasicAndReversedModel, BasicTypeInAnswerModel, ClozeModel,
    BasicNote, BasicAndReversedNote, BasicTypeInAnswerNote, ClozeNote, ListNote
)

from settingUtils.api_key_utils import require_llm

logger = logging.getLogger(__name__)

class Questions(BaseModel):
    Questions: List[str] = Field(description="A List of questions to be asked for studying the key points, terms, definitions, facts, context, and content of the provided document (paper, study notes, lecture slides, ...) very well.")

class QuestionWithAnswer(BaseModel):
    Question: str = Field(description="A Question to be asked for studying the key points, terms, definitions, facts, context, and content of a document (paper, study notes, lecture slides, ...) very well.")
    Answer: str = Field(description="The answer to the question with context and explanation.")

@require_llm
def QuestionGenerator(llm, questioning_chunk, n_questions, questioning_context, generated_questions):
    logger.debug("Starting QuestionGenerator")
    parser = JsonOutputParser(pydantic_object=Questions)
    fixing_parser = OutputFixingParser.from_llm(llm=llm, parser=parser, max_retries=1)
    prompt = PromptTemplate(
    template="""<|begin_of_text|><|start_header_id|>system<|end_header_id|>
    You are a question generating study assistant.
    You aim to generate a List of questions regarding the provided document.
    1. The questions should be designed to help the user study the key concepts, terms, definitions, and important points of the document very well. 
    2. They should aim to be clear, concise, and relevant to the document. 
    3. They should be designed to help the user gain a deep understanding of the document. 
    4. They should be fit for generating short flashcards for studying the document in terms of size and context. 
    5. They should prompt the user to apply the knowledge learned from the document. 
    6. They should ask for only one piece of information at a time.
    7. They should be in English. 
    8. They should NOT be about trivial details or irrelevant information. 
    9. They should NOT be too broad or too narrow. 
    10. They should NOT be subjective or opinion-based. 
    11. They should NOT be ambiguous or confusing. 
    12. They should NOT be leading or biased.

    Be mindful of what the user wants you to focus on in the document and the context of the questioning provided.
    Be mindful of the questions already generated by the user in the previous steps and aim to avoid duplicates.

    GENERATE EXACTLY {n_questions}! ONLY MAKE {n_questions} QUESTION!

    Here is the document: \n\n {document} \n\n

    Already generated questions: \n \n {generated_questions} \n \n

    {format_instructions}

    BEFORE SUBMITTING CHECK IF YOU HAVE GENERATED {n_questions} QUESTIONS! IF YOU GENERATES LESS THAN {n_questions}, THEN GENERATE MORE QUESTIONS!
    <|eot_id|><|start_header_id|>user<|end_header_id|>
    questioning context:
    '''
    {questioning_context}\n
    '''
    <|eot_id|><|start_header_id|>assistant<|end_header_id|>
    """,
    input_variables=["document", "n_questions", "questioning_context"],
    partial_variables={"format_instructions": parser.get_format_instructions()},
    )

    chain = prompt | llm | fixing_parser
    result = chain.invoke({"document": questioning_chunk, "n_questions": n_questions, "questioning_context": questioning_context, "generated_questions": generated_questions})
    logger.debug(f"Generated Questions: {result}")
    
    return result

@require_llm
def QuestionsDeduplicator(llm, questions, n_questions):
    logger.debug("Starting QuestionsDeduplicator")
    parser = JsonOutputParser(pydantic_object=Questions)
    fixing_parser = OutputFixingParser.from_llm(llm=llm, parser=parser, max_retries=1)
    prompt = PromptTemplate(
    template="""<|begin_of_text|><|start_header_id|>system<|end_header_id|>
    You are a question deduplicator. 
    You aim to remove duplicate questions from the list of questions generated by the question generating study assistant. 
    Remove any outright duplicates, questions that are too similar, questions that are asking the same thing in a different way, or have the same answer. 
    Keep the questions that are unique, clear, concise, and relevant to the document. 

    Provide the COMPLETE list of remaining questions with duplicates removed! Once you have listed all the questions, inspect the list you have provided for more 
    valid questions you could add and do that.
    Respond ONLY with the list of questions, no preamble or explanation needed. \n

    GENERATE EXACTLY {n_questions}! ONLY MAKE {n_questions} QUESTION!

    questions: \n
    '''
    {questions}\n
    '''\n
    {format_instructions}
    <|eot_id|><|start_header_id|>assistant<|end_header_id|>
    """,
    input_variables=["questions", "n_questions"],
    partial_variables={"format_instructions": parser.get_format_instructions()},
    )
    chain = prompt | llm | fixing_parser
    result = chain.invoke({"questions": questions, "n_questions": n_questions})
    logger.debug(f"Deduplicated Questions: {result}")
    return result


@require_llm
def BasicNoteGenerator(llm, question_with_answer):
    parser = JsonOutputParser(pydantic_object=BasicModel)
    fixing_parser = OutputFixingParser.from_llm(llm=llm, parser=parser, max_retries=1)    
    format_instructions = parser.get_format_instructions()
    prompt = PromptTemplate(
    template="""<|begin_of_text|><|start_header_id|>system<|end_header_id|>
    You are a flashcard generator. 
    You create flashcards of the type '{type}' for the user to study. \n
    The card should be short. It's fine to not use every information provided. \n
    The card should contain a prompt instead of a question. Example: "Capital of Paris" instead of "What is the capital of Paris?" \n
    You have been provided with a question and answer pair. \n
    Additionally you have been provided with guidelines for the '{type}' note type. \n
    Using the guidelines provided, create a flashcard of the '{type}' type. \n\n

    '''
    Questions and Answer:
    {question_with_answer}
    '''\n\n
    Flashcard Creation Guidelines: {how_to_use}\n
    Examples: {examples} \n
    Counter Examples: {counter_examples} \n

    Provide the response in the requested format without any preamble or explanation.
    Format Instructions: {format_instructions}
    <|eot_id|><|start_header_id|>assistant<|end_header_id|>""",
    input_variables=["type", "question_with_answer", "how_to_use", "examples", "counter_examples"],
    partial_variables={"format_instructions": format_instructions},
    )
    chain = prompt | llm | fixing_parser
    return chain.invoke({"question_with_answer": question_with_answer, "type": BasicNote.type, "how_to_use": BasicNote.how_to_use, "examples": BasicNote.examples, "counter_examples": BasicNote.counter_examples})

@require_llm
def BasicAndReversedNoteGenerator(llm, question_with_answer):
    parser = JsonOutputParser(pydantic_object=BasicAndReversedModel)
    fixing_parser = OutputFixingParser.from_llm(llm=llm, parser=parser, max_retries=1)
    format_instructions = parser.get_format_instructions()
    prompt = PromptTemplate(
    template="""<|begin_of_text|><|start_header_id|>system<|end_header_id|>
    You are a flashcard generator. 
    You create flashcards of the type '{type}' for the user to study. \n
    The front and back of the card should be reversible. Make sure that they do not need additonal context.\n
    The card should be short. It's fine to not use every information provided. \n
    The card should contain a prompt instead of a question. Example: "Capital of Paris" instead of "What is the capital of Paris?" \n
    You have been provided with a question and answer pair. \n
    Additionally you have been provided with guidelines for the '{type}' note type. \n
    Using the guidelines provided, create a flashcard of the '{type}' type. \n\n

    '''
    Questions and Answer:
    {question_with_answer}
    '''\n\n
    Flashcard Creation Guidelines: {how_to_use}\n
    Examples: {examples} \n
    Counter Examples: {counter_examples} \n

    Provide the response in the requested format without any preamble or explanation.
    Format Instructions: {format_instructions}
    <|eot_id|><|start_header_id|>assistant<|end_header_id|>""",
    input_variables=["type", "question_with_answer", "how_to_use", "examples", "counter_examples"],
    partial_variables={"format_instructions": format_instructions},
    )
    chain = prompt | llm | fixing_parser
    return chain.invoke({"question_with_answer": question_with_answer, "type": BasicAndReversedNote.type, "how_to_use": BasicAndReversedNote.how_to_use, "examples": BasicAndReversedNote.examples, "counter_examples": BasicAndReversedNote.counter_examples})

@require_llm
def BasicTypeInAnswerNoteGenerator(llm, question_with_answer):
    parser = JsonOutputParser(pydantic_object=BasicTypeInAnswerModel)
    fixing_parser = OutputFixingParser.from_llm(llm=llm, parser=parser, max_retries=1)
    format_instructions = parser.get_format_instructions()
    prompt = PromptTemplate(
    template="""<|begin_of_text|><|start_header_id|>system<|end_header_id|>
    You are a flashcard generator. 
    You create flashcards of the type '{type}' for the user to study. \n
    You have been provided with a question and answer pair. \n
    The card should be short. It's fine to not use every information provided. \n
    The card should contain a prompt instead of a question. Example: "Capital of Paris" instead of "What is the capital of Paris?" \n
    The answer/back should be only one word!
    Additionally you have been provided with guidelines for the '{type}' note type. \n
    Using the guidelines provided, create a flashcard of the '{type}' type. \n\n

    '''
    Questions and Answer:
    {question_with_answer}
    '''\n\n
    Flashcard Creation Guidelines: {how_to_use}\n
    Examples: {examples} \n
    Counter Examples: {counter_examples} \n

    Provide the response in the requested format without any preamble or explanation.
    Format Instructions: {format_instructions}
    <|eot_id|><|start_header_id|>assistant<|end_header_id|>""",
    input_variables=["type", "question_with_answer", "how_to_use", "examples", "counter_examples"],
    partial_variables={"format_instructions": format_instructions},
    )
    chain = prompt | llm | fixing_parser
    return chain.invoke({"question_with_answer": question_with_answer, "type": BasicTypeInAnswerNote.type, "how_to_use": BasicTypeInAnswerNote.how_to_use, "examples": BasicTypeInAnswerNote.examples, "counter_examples": BasicTypeInAnswerNote.counter_examples})

@require_llm
def ClozeNoteGenerator(llm, question_with_answer):
    parser = JsonOutputParser(pydantic_object=ClozeModel)
    fixing_parser = OutputFixingParser.from_llm(llm=llm, parser=parser, max_retries=1)
    format_instructions = parser.get_format_instructions()
    prompt = PromptTemplate(
    template="""<|begin_of_text|><|start_header_id|>system<|end_header_id|>
    You are a flashcard generator. 
    You create flashcards of the type '{type}' for the user to study. \n
    You NEED to write at least one cloze deletion. \n
    The card should be short. It's fine to not use every information provided. \n
    Focus on the main information. It should be one relatively short sentence. Focus on one key information!\n
    The card should contain a prompt instead of a question. Example: "Capital of Paris" instead of "What is the capital of Paris?" \n
    You have been provided with a question and answer pair. \n
    Additionally you have been provided with guidelines for the '{type}' note type. \n
    Using the guidelines provided, create a flashcard of the '{type}' type. \n\n

    '''
    Questions and Answer:
    {question_with_answer}
    '''\n\n
    Flashcard Creation Guidelines: {how_to_use}\n
    Examples: {examples} \n
    Counter Examples: {counter_examples} \n

    Provide the response in the requested format without any preamble or explanation.
    Format Instructions: {format_instructions}
    <|eot_id|><|start_header_id|>assistant<|end_header_id|>""",
    input_variables=["type", "question_with_answer", "how_to_use", "examples", "counter_examples"],
    partial_variables={"format_instructions": format_instructions},
    )
    chain = prompt | llm | fixing_parser
    data = chain.invoke({"question_with_answer": question_with_answer, "type": ClozeNote.type, "how_to_use": ClozeNote.how_to_use, "examples": ClozeNote.examples, "counter_examples": ClozeNote.counter_examples})
    data["Back Extra"] = data.pop("BackExtra")
    return data

@require_llm
def ListNoteGenerator(llm, question_with_answer):
    parser = JsonOutputParser(pydantic_object=ClozeModel)
    fixing_parser = OutputFixingParser.from_llm(llm=llm, parser=parser, max_retries=1)
    format_instructions = parser.get_format_instructions()
    prompt = PromptTemplate(
    template="""<|begin_of_text|><|start_header_id|>system<|end_header_id|>
    You are a flashcard generator. 
    You create flashcards of the type '{type}' for the user to study. \n
    You NEED to make a list! \n
    You NEED to write a cloze deletion for every item in the list. \n
    The card should be short. It's fine to not use every information provided. \n
    The card should contain a prompt instead of a question. Example: "Capital of Paris" instead of "What is the capital of Paris?" \n
    You have been provided with a question and answer pair. \n
    Additionally you have been provided with guidelines for the '{type}' note type. \n
    Using the guidelines provided, create a flashcard of the '{type}' type. \n\n

    '''
    Questions and Answer:
    {question_with_answer}
    '''\n\n
    Flashcard Creation Guidelines: {how_to_use}\n
    Examples: {examples} \n
    Counter Examples: {counter_examples} \n

    Provide the response in the requested format without any preamble or explanation.
    Format Instructions: {format_instructions}
    <|eot_id|><|start_header_id|>assistant<|end_header_id|>""",
    input_variables=["type", "question_with_answer", "how_to_use", "examples", "counter_examples"],
    partial_variables={"format_instructions": format_instructions},
    )
    chain = prompt | llm | fixing_parser
    data = chain.invoke({"question_with_answer": question_with_answer, "type": ListNote.type, "how_to_use": ListNote.how_to_use, "examples": ListNote.examples, "counter_examples": ListNote.counter_examples})
    data["Back Extra"] = data.pop("BackExtra")
    return data